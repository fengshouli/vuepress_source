# 你在哪里

过去类似的功能

## 1.chain-processor.

> 在中台,task模块,processor中,下面有个chain,以及一些***Processor,

### 1.chain.

> 链条,负责把相关的processor收集起来,一个一个执行.

我们来看一下这个类里面,

```java
@ProcessorChain(metaDataName = ***实体的Dto.ENTITY_NAME)
//这个注解代表着哪个实体dto的操作会进到这里面
public class *ProcessorChain extends BaseProcessorChain {
  //在这里注入涉及的processor.
  
  //在这里需要重写一些父类的方法,在下面我们详细介绍下.
}
```

**BaseProcessorChain**

这里面有几套方法,对应着一些默认实现

```java
//保存的时候,需要重写的是initSaveProcessors,下面都简写了.
@Override
public ProcessorCombination getSaveProcessors() {
    return getActionProcessors(ActionConsts.SAVE);
}
protected ProcessorCombination initSaveProcessors(){
    return null;
}

			//删除时候
  initDeleteProcessors
  		//审批时候
  initApproveProcessors
      //弃审时候
  initUnApproveProcessors
      //提交时候
  initSubmitProcessors
      //撤回时候
  initUnSubmitProcessors
      //*时候
  initAddProcessors
    //用户自定义场景.
  initCustomizeProcessors
```

### 2.processor.

> 具体的某个流程点.

随便拿一个processor举例吧

```java
public class ***AfterProcessor implements IPreProcessor/IPostProcessor<***Dto, ***DomainObject> {

  //这里已经自动拿到了dto和领域对象了,这两个对象是调用者传来的,例如BaseAppService调用,
  //在调用者中,调用dto自己的converter转换来的.这也就是为什么converter需要实现IBizConverter<***Dto,***DomainObj>
    @Override
    public void process(ProjectTask domainObject, ProjectScheduleTaskDto dto) throws BusinessException {
        function(dto);
    }

    private void function(ProjectScheduleTaskDto dto) {
        //...
    }
}
```

## 2.onApplicationEvent

> 中台的service中,TaskRecordServiceImpl.java中用到过.

事件,一般我们用这个东西来这么一个事,当程序加载后,取出某个类型(实现,继承了某个接口)的类,收集到一起.

举个例子:

```java
//初始化
public class ***Service implements ApplicationListener<ApplicationReadyEvent> {
      private Map<String, Function<1Dto,2Dto>> serviceDispatcher = new HashMap<>();

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        ApplicationContext applicationContext = event.getApplicationContext();

        Map<String, 接口Service> dispatcher = applicationContext.getBeansOfType(接口Service.class);

        if(CollectionUtils.isEmpty(dispatcher)){
            return;
        }

        for (Map.Entry<String,接口Service > map : dispatcher.entrySet()) {
            接口Service service = map.getValue();
            serviceDispatcher.put(service.appoingDispatcher(),service::getSome);
        }
    }
}

//用的时候
dispatcher = recordExecDispatcher.get(type);//这个type就是appoingDispatcher指定的那个
dispatcher.doSome();

//一般的接口至少包含这么几个方法
1.protected abstract String appoingDispatcher();//指定当前实现的名字,和注解@Service("这个指定是一样的")
2.protected abstract Object DoSome(***Dto dto);//每个实现做的事

```

* ApplicationReadyEvent:表示application应用初始化完成,可以接受请求.

## 3.MapList.

> 中台的web,task的vo中,QueryTaskResultVo.java用到过.creationBy方法

> MapList维护了一个key对一个列表的映射关系。每次放入一个键值对时， 会将值放在该键对应的列表中，如果列表不存在则创建列表

```java
MapList<ProjectScheduleStatus,ProjectScheduleTaskDto> mapList = new MapList();
for (ProjectScheduleTaskDto taskDto : taskDtos) {
  mapList.put(ProjectScheduleStatus.getValue(taskDto.getTaskStatus()),taskDto);
}
```

## 4.批量翻译参照.

> 中台项目的web-adapter中,projecttask,translator中,ProjectTaskTranslator类,getHeaderRefMap方法.

```java
 private Map<String, Map<String, Object>> getHeaderRefMap(ProjectScheduleTaskDto projectScheduleTaskDto) {
        List<FillParam> fillParams = new ArrayList<>();

        Long supplierId = projectScheduleTaskDto.getSupplierId();
        if(supplierId != null) {
            ReferInfo supplierRefer = new ReferInfo(PMReferConsts.SUPPLIER_REF_CODE,
                    PMReferConsts.SUPPLIER_REF_DOMAIN,
                    PMReferConsts.SUPPLIER_REF_ENTITY_NAME);
            fillParams.add(new FillParam(
                    buildQueryCondition(supplierId),
                    defaultFields,
                    returnSupplier,
                    supplierRefer));
        }
         //其他参照翻译
         //其他参照翻译
         //其他参照翻译
        PMReferFillManager.getInstance().fill(fillParams,true);
        Map<String, Map<String, Object>> refMap = buildReturnData(fillParams);
        return refMap;
    }
```

## 5.controller结束对象中Date类型直接转换.

> 中台项目,web-adapter,projecttask包,TaskController类,updateTaskStateToComplete方法.

```java
public void updateTaskStateToComplete(HttpServletResponse response,@RequestBody TaskStateUpdateParamDto taskStateUpdateParamDto) {
}

public class TaskStateUpdateParamDto {
    //这个注解是将前台的日期参数转为date,需要配合接收参数处,@RequestBody 注解
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date pubts;
}
```

## 6.设置小数点精度为币种精度.

> 前端中台项目,PGRM_prjc_taskworkbench_task_detail_window_VM.Extend.js;中,init,

```js
let suc = viewmodel.getParams().taskData
let applyAmount = viewmodel.get("applyAmount");

//保留精度小数位并转字符串
applyAmount.setState('iNumPoint', suc.moneyDigit)
```

前提条件.返回的数据中,数字字段绑定了精度字段,精度也有值,并且数字字段的类型为InputNumber.

## 7.指定执行器,执行通用流程自定义action.

> 中台,service,task,service,executor...com.yonyou.pmcloud.application.project.task.service.executor.BaseExecutor

在service中,调用

```java
BaseExecutor.getExecutor(TaskExecutorConst.SAVE_EXECUTOR).execute(taskDto);
```

来使用.

这里还有重写`BaseExtendService` 的方法.SaveExecutor.java