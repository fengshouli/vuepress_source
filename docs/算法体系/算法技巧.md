# 算法技巧

### 1.宽度优先遍历

核心:1.队列 2.size .

用队列,按层遍历.将每一层的东西放到队列,弹出一个,加入所有他的子级,当这一层的size个遍历完后,size变成当前队列的长度,代表下一层的需要变量的个数.

```java

```

### 2.数组全排列

分治的那种,全排列,左右分别展开,

### 3.有限变量的Map可以由数组替代而加速



### 4.取一半/翻一倍

二分的时候,经常遇到

```java
nums >> 1 //带符号右移 取一半
L + ((R - L) >> 1) //防止越界
nums << 1 //翻一倍
```



### 5.二分查找法

```java
//在有序数组arr中，用二分的方法数出<limit的数有几个
// 也就是用二分法，找到<limit的数中最右的位置
private int countLess(ArrayList<Integer> arr, int limit) {
			int L = 0;
			int R = arr.size() - 1;
			int mostRight = -1;
			while (L <= R) {
				int mid = L + ((R - L) >> 1);
				if (arr.get(mid) < limit) {
					mostRight = mid;
					L = mid + 1;
				} else {
					R = mid - 1;
				}
			}
			return mostRight + 1;
		}
```

### 6.二叉树如何快速找前驱后继

1. 后继:中序遍历中,一个节点的下一个节点,就是后继.最后一个节点没有后继.
   1. 树中的一个x节点,他的右树的最左孩子,就是他的后继.
   2. 如果X他没有右孩子,那么,他与他的父亲是右链接,就继续往上找.直到找到第一个左连接关系的Y,Y就是X的后继.
2. 前驱:中序遍历中,一个节点的前一个节点,就是前驱.第一个节点没有前驱.跟后继是反着的.
   1. 树中的一个x节点,他的左树的最右孩子,就是他的前驱节点.
   2. 如果x他没有左孩子,那么,他与他的父亲是左连接,就继续往上找,直到找到第一个右连接关系的Y,Y就是X的前驱.

用栈,以 前驱 举例.做一个栈.

从头节点开始,所有的数,只要>target,先压栈,就往左滑,

看看左滑的数,是否>target,如果小于,往右滑,重复上面的步骤,右滑后,大于,压栈,然后左滑.

然后小于的话,直接右滑,,右滑后大于则压栈然后左滑,

走完了,或者找到了等于target的值,压栈,退出.

栈里的是什么,是target的所有的要往左滑的节点.如果说,X的没有左树,那就要一个个的弹出,弹出的就是前驱节点.