<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>spring知识汇总 | 冯手力-java学习之路</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.1c15f983.css" as="style"><link rel="preload" href="/assets/js/app.18fa8910.js" as="script"><link rel="preload" href="/assets/js/2.d4087e47.js" as="script"><link rel="preload" href="/assets/js/22.d7e1abe0.js" as="script"><link rel="prefetch" href="/assets/js/10.0e30a326.js"><link rel="prefetch" href="/assets/js/11.dd81c618.js"><link rel="prefetch" href="/assets/js/12.bfaf62ee.js"><link rel="prefetch" href="/assets/js/13.bbb29b3e.js"><link rel="prefetch" href="/assets/js/14.7ad4e45b.js"><link rel="prefetch" href="/assets/js/15.a5e7f973.js"><link rel="prefetch" href="/assets/js/16.534170d4.js"><link rel="prefetch" href="/assets/js/17.ef4f525b.js"><link rel="prefetch" href="/assets/js/18.47a6b1c2.js"><link rel="prefetch" href="/assets/js/19.cedc1cce.js"><link rel="prefetch" href="/assets/js/20.1ffe1c47.js"><link rel="prefetch" href="/assets/js/21.f2cdc78f.js"><link rel="prefetch" href="/assets/js/23.fd84a8b5.js"><link rel="prefetch" href="/assets/js/24.d59ee447.js"><link rel="prefetch" href="/assets/js/25.8f5c9bbd.js"><link rel="prefetch" href="/assets/js/26.b9299e08.js"><link rel="prefetch" href="/assets/js/27.d2b9cc7a.js"><link rel="prefetch" href="/assets/js/28.78d33527.js"><link rel="prefetch" href="/assets/js/29.4a658e0d.js"><link rel="prefetch" href="/assets/js/3.5e52e679.js"><link rel="prefetch" href="/assets/js/30.2b1cec26.js"><link rel="prefetch" href="/assets/js/31.07d40c89.js"><link rel="prefetch" href="/assets/js/32.8fc4a727.js"><link rel="prefetch" href="/assets/js/33.95013e87.js"><link rel="prefetch" href="/assets/js/34.ef3c89a4.js"><link rel="prefetch" href="/assets/js/35.5550c81e.js"><link rel="prefetch" href="/assets/js/36.325eb3ab.js"><link rel="prefetch" href="/assets/js/37.b2ed41a4.js"><link rel="prefetch" href="/assets/js/38.447431d3.js"><link rel="prefetch" href="/assets/js/39.5a227a7c.js"><link rel="prefetch" href="/assets/js/4.e98e4ac8.js"><link rel="prefetch" href="/assets/js/5.24f96648.js"><link rel="prefetch" href="/assets/js/6.37e05327.js"><link rel="prefetch" href="/assets/js/7.2532c624.js"><link rel="prefetch" href="/assets/js/8.304c90a0.js"><link rel="prefetch" href="/assets/js/9.3ca4f0e3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1c15f983.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">冯手力-java学习之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><a href="/工作经验/" class="nav-link">
  工作经验
</a></div><div class="nav-item"><a href="/项目经验/" class="nav-link">
  项目经验
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java知识
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库知识
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><a href="/工作经验/" class="nav-link">
  工作经验
</a></div><div class="nav-item"><a href="/项目经验/" class="nav-link">
  项目经验
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java知识
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库知识
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/java/" aria-current="page" class="sidebar-link">java底层基础知识</a></li><li><a href="/java/java_base.html" class="sidebar-link">java关键字</a></li><li><a href="/java/lambda.html" class="sidebar-link">lambda</a></li><li><a href="/java/juc.html" class="sidebar-link">JUC</a></li><li><a href="/java/Kafka.html" class="sidebar-link">Kafka</a></li><li><a href="/java/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/java/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/java/spring.html" aria-current="page" class="active sidebar-link">spring知识汇总</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/spring.html#_1-谈谈spring-ioc的理解-原理与实现" class="sidebar-link">1.谈谈Spring IOC的理解，原理与实现?</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_2-谈一下spring-ioc的底层实现" class="sidebar-link">2.谈一下spring IOC的底层实现</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_3-描述一下bean的生命周期" class="sidebar-link">3.描述一下bean的生命周期 ？</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_4-spring-是如何解决循环依赖的问题的" class="sidebar-link">4.Spring 是如何解决循环依赖的问题的？</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_4-1缓存的放置时间和删除时间" class="sidebar-link">4.1缓存的放置时间和删除时间</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_5-bean-factory与factorybean有什么区别" class="sidebar-link">5.Bean Factory与FactoryBean有什么区别？</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_6-spring中用到的设计模式" class="sidebar-link">6.Spring中用到的设计模式?</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_7-spring的aop的底层实现原理" class="sidebar-link">7.Spring的AOP的底层实现原理?</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_8-spring的事务是如何回滚的" class="sidebar-link">8.Spring的事务是如何回滚的?</a></li><li class="sidebar-sub-header"><a href="/java/spring.html#_9-谈一下spring事务传播" class="sidebar-link">9.谈一下spring事务传播？</a></li></ul></li><li><a href="/java/SpringBoot.html" class="sidebar-link">SpringBoot</a></li><li><a href="/java/SpringCloud.html" class="sidebar-link">SpringCloud学习</a></li><li><a href="/java/总结的题目.html" class="sidebar-link">总结的题目</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="spring知识汇总"><a href="#spring知识汇总" class="header-anchor">#</a> spring知识汇总</h1> <p>答题技巧：</p> <p>总：当前问题回答的是那些具体的点</p> <p>分：以1，2，3，4，5的方式分细节取描述相关的知识点，如果有哪些点不清楚，直接忽略过去</p> <p>​		突出一些技术名词（核心概念，接口，类，关键方法）</p> <p>​		避重就轻：没有重点</p> <p>一个问题能占用面试官多少时间？问的越多可能露馅越多</p> <p>当面试官问到一个你熟悉的点的时候，一定要尽量拖时间</p> <h2 id="_1-谈谈spring-ioc的理解-原理与实现"><a href="#_1-谈谈spring-ioc的理解-原理与实现" class="header-anchor">#</a> 1.谈谈Spring IOC的理解，原理与实现?</h2> <p><strong>总：</strong></p> <p>控制反转：理论思想，原来的对象是由使用者来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理</p> <p>​				DI：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，@populateBean完成属性值的注入</p> <p>容器：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjects存放完整的bean对象,</p> <p>​			整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理（bean的生命周期）</p> <p><strong>分：</strong></p> <p>1、一般聊ioc容器的时候要涉及到容器的创建过程（beanFactory,DefaultListableBeanFactory）,向bean工厂中设置一些参数（BeanPostProcessor,Aware接口的子类）等等属性</p> <p>2、加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition,(xml或者注解的解析过程)</p> <p>3、beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSupport,ConfigurationClassPostProcessor</p> <p>4、BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p> <p>5、通过反射的方式讲BeanDefinition对象实例化成具体的bean对象，</p> <p>6、bean对象的初始化过程（填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-mehtod方法，调用BeanPostProcessor的后置处理方法）</p> <p>7、生成完整的bean对象，通过getBean方法可以直接获取</p> <p>8、销毁过程</p> <p>面试官，这是我对ioc的整体理解，包含了一些详细的处理过程，您看一下有什么问题，可以指点我一下（允许你把整个流程说完）</p> <p>您有什么想问的？</p> <p>​			老师，我没看过源码怎么办？</p> <p>​		具体的细节我记不太清了，但是spring中的bean都是通过反射的方式生成的，同时其中包含了很多的扩展点，比如最常用的对BeanFactory的扩展，对bean的扩展（对占位符的处理），我们在公司对这方面的使用是比较多的，除此之外，ioc中最核心的也就是填充具体bean的属性，和生命周期（背一下）。</p> <h2 id="_2-谈一下spring-ioc的底层实现"><a href="#_2-谈一下spring-ioc的底层实现" class="header-anchor">#</a> 2.谈一下spring IOC的底层实现</h2> <p>底层实现：工作原理，过程，数据结构，流程，设计模式，设计思想</p> <p>其实他想问的是:你对他的理解和你了解过的实现过程</p> <p>反射，工厂，设计模式（会的说，不会的不说），关键的几个方法</p> <p>createBeanFactory，getBean,doGetBean,createBean,doCreateBean,createBeanInstance(getDeclaredConstructor,newinstance),populateBean,initializingBean</p> <p>1、先通过createBeanFactory创建出一个Bean工厂（DefaultListableBeanFactory）</p> <p>2、开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean,doGetBean从容器中查找，找不到的话，</p> <p>3、通过createBean,doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造方法（getDeclaredConstructor，newInstance）</p> <p>4、进行对象的属性填充populateBean</p> <p>5、进行其他的初始化操作（initializingBean）</p> <h2 id="_3-描述一下bean的生命周期"><a href="#_3-描述一下bean的生命周期" class="header-anchor">#</a> 3.描述一下bean的生命周期 ？</h2> <p>背图：记住图中的流程</p> <p>在表述的时候不要只说图中有的关键点，要学会扩展描述</p> <p>1、实例化bean：反射的方式生成对象</p> <p>2、填充bean的属性：populateBean(),循环依赖的问题（三级缓存）</p> <p>3、调用aware接口相关的方法：invokeAwareMethod(完成BeanName,BeanFactory,BeanClassLoader对象的属性设置)</p> <p>4、调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor,设置ApplicationContext,Environment,ResourceLoader,EmbeddValueResolver等对象）</p> <p>5、调用initmethod方法：invokeInitmethod(),判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</p> <p>6、调用BeanPostProcessor的后置处理方法：spring的aop就是在此处实现的，AbstractAutoProxyCreator</p> <p>​		注册Destuction相关的回调接口：钩子函数</p> <p>7、获取到完整的对象，可以通过getBean的方式来进行对象的获取</p> <p>8、销毁流程，1；判断是否实现了DispoableBean接口，2，调用destroyMethod方法</p> <h2 id="_4-spring-是如何解决循环依赖的问题的"><a href="#_4-spring-是如何解决循环依赖的问题的" class="header-anchor">#</a> 4.Spring 是如何解决循环依赖的问题的？</h2> <p>三级缓存，提前暴露对象，aop</p> <p>总：什么是循环依赖问题，A依赖B,B依赖A</p> <p>分：先说明bean的创建过程：实例化，初始化（填充属性）</p> <p>​		1、先创建A对象，实例化A对象，此时A对象中的b属性为空，填充属性b</p> <p>​		2、从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题（不通），找不到直接创建B对象</p> <p>​		3、实例化B对象，此时B对象中的a属性为空，填充属性a</p> <p>​		4、从容器中查找A对象，找不到，直接创建</p> <p>​		形成闭环的原因</p> <p>​		此时，如果仔细琢磨的话，会发现A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象的引用，所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的关键，</p> <p>​		当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几个状态，完成实例化=但未完成初始化，完整状态，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方式来查找的。一级缓存中放的是完整对象，二级缓存中放的是非完整对象</p> <p>​		为什么需要三级缓存？三级缓存的value类型是ObjectFactory,是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。</p> <p>​		如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要</p> <p>​		普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()</p> <p>​		因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p> <h2 id="_4-1缓存的放置时间和删除时间"><a href="#_4-1缓存的放置时间和删除时间" class="header-anchor">#</a> 4.1缓存的放置时间和删除时间</h2> <p>​		三级缓存：createBeanInstance之后：addSingletonFactory</p> <p>​		二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存 getSingleton</p> <p>​		一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存:addSingleton</p> <h2 id="_5-bean-factory与factorybean有什么区别"><a href="#_5-bean-factory与factorybean有什么区别" class="header-anchor">#</a> 5.Bean Factory与FactoryBean有什么区别？</h2> <p>相同点：都是用来创建bean对象的</p> <p>不同点：使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了，，如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactroyBean接口了</p> <p>​			isSingleton:是否是单例对象</p> <p>​			getObjectType:获取返回对象的类型</p> <p>​			getObject:自定义创建对象的过程(new，反射，动态代理)</p> <h2 id="_6-spring中用到的设计模式"><a href="#_6-spring中用到的设计模式" class="header-anchor">#</a> 6.Spring中用到的设计模式?</h2> <p>单例模式：bean默认都是单例的</p> <p>原型模式：指定作用域为prototype</p> <p>工厂模式：BeanFactory</p> <p>模板方法：postProcessBeanFactory,onRefresh,initPropertyValue</p> <p>策略模式：XmlBeanDefinitionReader,PropertiesBeanDefinitionReader</p> <p>观察者模式：listener，event，multicast</p> <p>适配器模式：Adapter</p> <p>装饰者模式：BeanWrapper</p> <p>责任链模式：使用aop的时候会先生成一个拦截器链</p> <p>代理模式：动态代理</p> <p>委托者模式：delegate</p> <p>。。。。。。。。。</p> <h2 id="_7-spring的aop的底层实现原理"><a href="#_7-spring的aop的底层实现原理" class="header-anchor">#</a> 7.Spring的AOP的底层实现原理?</h2> <p>动态代理</p> <p>aop是ioc的一个扩展功能，先有的ioc，再有的aop，只是在ioc的整个流程中新增的一个扩展点而已：BeanPostProcessor</p> <p>总：aop概念，应用场景，动态代理</p> <p>分：</p> <p>​		bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现</p> <p>​		1、代理对象的创建过程（advice，切面，切点）</p> <p>​		2、通过jdk或者cglib的方式来生成代理对象</p> <p>​		3、在执行方法调用的时候，会调用到生成的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的intercept方法，从此方法开始执行</p> <p>​		4、根据之前定义好的通知来生成拦截器链</p> <p>​		5、从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个CglibMethodInvocation的对象，找的时候是从-1的位置一次开始查找并且执行的。</p> <h2 id="_8-spring的事务是如何回滚的"><a href="#_8-spring的事务是如何回滚的" class="header-anchor">#</a> 8.Spring的事务是如何回滚的?</h2> <p>​		spring的事务管理是如何实现的？</p> <p>​		总：spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p> <p>​		分：1、先做准备工作，解析各个方法上事务相关的属性，根据具体的属性来判断是否开始新事务</p> <p>​				2、当需要开启的时候，获取数据库连接，关闭自动提交功能，开起事务</p> <p>​				3、执行具体的sql逻辑操作</p> <p>​				4、在操作过程中，如果执行失败了，那么会通过completeTransactionAfterThrowing看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是要先获取连接对象，通过连接对象来回滚</p> <p>​				5、如果执行过程中，没有任何意外情况的发生，那么通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实现的，实现的时候也是要获取连接，通过连接对象来提交</p> <p>​				6、当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo</p> <p>如果想要聊的更加细致的话，需要知道TransactionInfo,TransactionStatus,</p> <h2 id="_9-谈一下spring事务传播"><a href="#_9-谈一下spring事务传播" class="header-anchor">#</a> 9.谈一下spring事务传播？</h2> <p>​			传播特性有几种？7种</p> <p>​			Required,Requires_new,nested,Support,Not_Support,Never,Mandatory</p> <p>​			某一个事务嵌套另一个事务的时候怎么办？</p> <p>​			A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</p> <hr> <p>​			总：事务的传播特性指的是不同方法的嵌套调用过程中，事务应该如何进行处理，是用同一个事务还是不同的事务，当出现异常的时候会回滚还是提交，两个方法之间的相关影响，在日常工作中，使用比较多的是required，Requires_new,nested</p> <p>​			分：1、先说事务的不同分类，可以分为三类：支持当前事务，不支持当前事务，嵌套事务</p> <p>​					2、如果外层方法是required，内层方法是，required,requires_new,nested</p> <p>​					3、如果外层方法是requires_new，内层方法是，required,requires_new,nested</p> <p>​					4、如果外层方法是nested，内层方法是，required,requires_new,nested</p> <p>​</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/Redis.html" class="prev">
        Redis
      </a></span> <span class="next"><a href="/java/SpringBoot.html">
        SpringBoot
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.18fa8910.js" defer></script><script src="/assets/js/2.d4087e47.js" defer></script><script src="/assets/js/22.d7e1abe0.js" defer></script>
  </body>
</html>
