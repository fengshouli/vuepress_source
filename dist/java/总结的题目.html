<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>总结的题目 | 冯手力-java学习之路</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.1c15f983.css" as="style"><link rel="preload" href="/assets/js/app.18fa8910.js" as="script"><link rel="preload" href="/assets/js/2.d4087e47.js" as="script"><link rel="preload" href="/assets/js/23.fd84a8b5.js" as="script"><link rel="prefetch" href="/assets/js/10.0e30a326.js"><link rel="prefetch" href="/assets/js/11.dd81c618.js"><link rel="prefetch" href="/assets/js/12.bfaf62ee.js"><link rel="prefetch" href="/assets/js/13.bbb29b3e.js"><link rel="prefetch" href="/assets/js/14.7ad4e45b.js"><link rel="prefetch" href="/assets/js/15.a5e7f973.js"><link rel="prefetch" href="/assets/js/16.534170d4.js"><link rel="prefetch" href="/assets/js/17.ef4f525b.js"><link rel="prefetch" href="/assets/js/18.47a6b1c2.js"><link rel="prefetch" href="/assets/js/19.cedc1cce.js"><link rel="prefetch" href="/assets/js/20.1ffe1c47.js"><link rel="prefetch" href="/assets/js/21.f2cdc78f.js"><link rel="prefetch" href="/assets/js/22.d7e1abe0.js"><link rel="prefetch" href="/assets/js/24.d59ee447.js"><link rel="prefetch" href="/assets/js/25.8f5c9bbd.js"><link rel="prefetch" href="/assets/js/26.b9299e08.js"><link rel="prefetch" href="/assets/js/27.d2b9cc7a.js"><link rel="prefetch" href="/assets/js/28.78d33527.js"><link rel="prefetch" href="/assets/js/29.4a658e0d.js"><link rel="prefetch" href="/assets/js/3.5e52e679.js"><link rel="prefetch" href="/assets/js/30.2b1cec26.js"><link rel="prefetch" href="/assets/js/31.07d40c89.js"><link rel="prefetch" href="/assets/js/32.8fc4a727.js"><link rel="prefetch" href="/assets/js/33.95013e87.js"><link rel="prefetch" href="/assets/js/34.ef3c89a4.js"><link rel="prefetch" href="/assets/js/35.5550c81e.js"><link rel="prefetch" href="/assets/js/36.325eb3ab.js"><link rel="prefetch" href="/assets/js/37.b2ed41a4.js"><link rel="prefetch" href="/assets/js/38.447431d3.js"><link rel="prefetch" href="/assets/js/39.5a227a7c.js"><link rel="prefetch" href="/assets/js/4.e98e4ac8.js"><link rel="prefetch" href="/assets/js/5.24f96648.js"><link rel="prefetch" href="/assets/js/6.37e05327.js"><link rel="prefetch" href="/assets/js/7.2532c624.js"><link rel="prefetch" href="/assets/js/8.304c90a0.js"><link rel="prefetch" href="/assets/js/9.3ca4f0e3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1c15f983.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">冯手力-java学习之路</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><a href="/工作经验/" class="nav-link">
  工作经验
</a></div><div class="nav-item"><a href="/项目经验/" class="nav-link">
  项目经验
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java知识
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库知识
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/操作/" class="nav-link">
  操作
</a></div><div class="nav-item"><a href="/工作经验/" class="nav-link">
  工作经验
</a></div><div class="nav-item"><a href="/项目经验/" class="nav-link">
  项目经验
</a></div><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  java知识
</a></div><div class="nav-item"><a href="/数据库/" class="nav-link">
  数据库知识
</a></div><div class="nav-item"><a href="/源码解析/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/算法体系/" class="nav-link">
  算法体系
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/java/" aria-current="page" class="sidebar-link">java底层基础知识</a></li><li><a href="/java/java_base.html" class="sidebar-link">java关键字</a></li><li><a href="/java/lambda.html" class="sidebar-link">lambda</a></li><li><a href="/java/juc.html" class="sidebar-link">JUC</a></li><li><a href="/java/Kafka.html" class="sidebar-link">Kafka</a></li><li><a href="/java/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/java/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/java/spring.html" class="sidebar-link">spring知识汇总</a></li><li><a href="/java/SpringBoot.html" class="sidebar-link">SpringBoot</a></li><li><a href="/java/SpringCloud.html" class="sidebar-link">SpringCloud学习</a></li><li><a href="/java/总结的题目.html" class="active sidebar-link">总结的题目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_0-简历上写的一定要会" class="sidebar-link">0.简历上写的一定要会</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_1-spring事务是怎么实现的-事务失效的情况分析" class="sidebar-link">1.Spring事务是怎么实现的,事务失效的情况分析</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_2-zookeeper的锁如何应用" class="sidebar-link">2.zookeeper的锁如何应用</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_3-mysql和oracle的区别" class="sidebar-link">3.MySql和Oracle的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#一、宏观上" class="sidebar-link">一、宏观上:</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#二、微观上" class="sidebar-link">二、微观上:</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_4-weblogic和tomcat的区别" class="sidebar-link">4.Weblogic和Tomcat的区别</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_5-gc有哪些回收器" class="sidebar-link">5.gc有哪些回收器.</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#一、串行垃圾回收器" class="sidebar-link">一、串行垃圾回收器</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#二、并行垃圾回收器" class="sidebar-link">二、并行垃圾回收器</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#三、cms收集器" class="sidebar-link">三、CMS收集器</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#四、g1垃圾收集器" class="sidebar-link">四、G1垃圾收集器</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_6-内存新生代-老年代等" class="sidebar-link">6.内存新生代.老年代等</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#jvm-对象什么情况会进入到老年代" class="sidebar-link">JVM--对象什么情况会进入到老年代</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_7-为什么需要分布式锁" class="sidebar-link">7.为什么需要分布式锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#什么是分布式锁" class="sidebar-link">什么是分布式锁</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#为什么需要分布式锁" class="sidebar-link">为什么需要分布式锁</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_8-工厂-代理模式-好好看看" class="sidebar-link">8.工厂,代理模式,好好看看.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_9-hashmap是线程安全吗-为啥" class="sidebar-link">9.HashMap是线程安全吗,为啥</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_10-gc线上调优经验-如果写了会被问" class="sidebar-link">10.gc线上调优经验(如果写了会被问)</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_11-说说如果你想用zookeeper怎么用" class="sidebar-link">11.说说如果你想用zookeeper怎么用.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_12-redis和zookeeper的分布式锁有什么区别" class="sidebar-link">12.redis和zookeeper的分布式锁有什么区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/总结的题目.html#zookeeper实现分布式锁的原理" class="sidebar-link">zookeeper实现分布式锁的原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_13-thread和runnable的顶级父类是什么" class="sidebar-link">13.Thread和Runnable的顶级父类是什么</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_14-spring中用了哪些设计模式" class="sidebar-link">14.spring中用了哪些设计模式</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_15-concurrenthashmap的链表为什么8个就转为红黑树" class="sidebar-link">15.ConcurrentHashMap的链表为什么8个就转为红黑树</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_16-innodb和myisam的区别和使用" class="sidebar-link">16.Innodb和myisam的区别和使用</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_17-map是如何实现的" class="sidebar-link">17.map是如何实现的</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_18-红黑树" class="sidebar-link">18.红黑树</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#" class="sidebar-link"></a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_19-mysql事务隔离级别" class="sidebar-link">19.mysql事务隔离级别</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_20-索引失效的情况-详见sql-md" class="sidebar-link">20.索引失效的情况,详见sql.md</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_21-tcp三次握手-四次挥手" class="sidebar-link">21.tcp三次握手,四次挥手</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_22-一致性哈希原理" class="sidebar-link">22.一致性哈希原理</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_23-redis数据类型-及实现原理" class="sidebar-link">23.Redis数据类型.及实现原理</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_24-lambda并行的线程池和java线程池的区别" class="sidebar-link">24.lambda并行的线程池和java线程池的区别</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_24-1-java线程池7个参数-四个实现方式-队列和最大线程数执行顺序" class="sidebar-link">24.1.java线程池7个参数,四个实现方式,队列和最大线程数执行顺序.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_25-java中解决了aba问题的类" class="sidebar-link">25.java中解决了ABA问题的类</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_26-cas全拼是什么-他的set的实现细节" class="sidebar-link">26.CAS全拼是什么.他的set的实现细节</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_27-redis的原子setnx是在哪个版本出现的" class="sidebar-link">27.redis的原子setnx是在哪个版本出现的</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_28-redis的set-kv-nx-ex-是怎么保证原子的" class="sidebar-link">28.redis的set kv nx ex  是怎么保证原子的.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_29-mysql如何排查死锁问题" class="sidebar-link">29.mysql如何排查死锁问题.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_30-innodb什么时候表锁-什么时候行锁" class="sidebar-link">30.innodb什么时候表锁,什么时候行锁.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_31-java如何排查死锁" class="sidebar-link">31.java如何排查死锁.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_32-向hashset中插入自定义的类有什么需要注意的" class="sidebar-link">32.向hashset中插入自定义的类有什么需要注意的.</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_33-hashmap和hashset的底层" class="sidebar-link">33.hashMap和hashSet的底层</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_34-hashset类是如何实现添加元素保证不重复的" class="sidebar-link">34.HashSet类是如何实现添加元素保证不重复的</a></li><li class="sidebar-sub-header"><a href="/java/总结的题目.html#_35-redis在你的项目中你是怎么用的-redis锁的注意事项" class="sidebar-link">35.redis在你的项目中你是怎么用的.redis锁的注意事项.</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="总结的题目"><a href="#总结的题目" class="header-anchor">#</a> 总结的题目</h1> <h2 id="_0-简历上写的一定要会"><a href="#_0-简历上写的一定要会" class="header-anchor">#</a> 0.简历上写的一定要会</h2> <h2 id="_1-spring事务是怎么实现的-事务失效的情况分析"><a href="#_1-spring事务是怎么实现的-事务失效的情况分析" class="header-anchor">#</a> 1.Spring事务是怎么实现的,事务失效的情况分析</h2> <p>在进行事务支持时，Spring只需要使用者在需要事务支持的bean上使用<code>@Transactional</code>注解即可，如果需要修改事务的隔离级别和传播特性的属性，则使用该注解中的属性进行指定。</p> <p>失效情况</p> <ol><li>注解不是在public上
<ol><li>基于动态代理实现的,创建代理对象时候,如果不是public的,就认为Transactional信息为空,就不会进行代理了.</li></ol></li> <li>在一个类内部调用事务方法
<ol><li>如果是内部调用,那么也不是通过代理对象来调用,而是通过this对象进行调用.绕过了代理对象.肯定没有代理逻辑了.</li></ol></li> <li>事务内部捕捉了异常,没有抛出新的异常
<ol><li>通过源码解析看到,事务回滚必须捕捉到异常,但是异常中途被捕捉,事务将不会回滚</li></ol></li></ol> <p><strong>事务的隔离级别</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1. @Transactional(isolation = Isolation.READ_UNCOMMITTED)：读取未提交数据(会出现脏读,不可重复读) 基本不使用
2. @Transactional(isolation = Isolation.READ_COMMITTED)：读取已提交数据(会出现不可重复读和幻读)
3. @Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读(会出现幻读)
4. @Transactional(isolation = Isolation.SERIALIZABLE)：串行化
</code></pre></div><h2 id="_2-zookeeper的锁如何应用"><a href="#_2-zookeeper的锁如何应用" class="header-anchor">#</a> 2.zookeeper的锁如何应用</h2> <p><strong>Zookeeper 分布式锁的原理</strong></p> <p>Zookeeper 分布式锁恰恰应用了临时顺序节点。</p> <ol><li>首先，在 Zookeeper 当中创建一个持久节点 ParentLock。</li> <li>每个客户端来了后,需要在这个节点下创建一个有序临时节点,并且判断他这个节点是不是最小的一个,如果是,那么代表他获取锁成功.</li> <li>剩下的客户端创建的有序临时节点,按顺序排好,并设置一个watch来观察前一个节点,这个时候,可以有序维持一个队列.</li></ol> <p>释放锁分为两种情况：</p> <ol><li><p>任务完成，客户端显示释放</p> <p>当任务完成时，Client1 会显示调用删除节点 Lock1 的指令。</p></li> <li><p>任务执行过程中，客户端崩溃</p> <p>获得锁的 Client1 在任务执行过程中，如果崩溃，则会断开与 Zookeeper 服务端的链接。根据临时节点的特性，相关联的节点 Lock1 会随之自动删除。</p></li></ol> <p>Zookeeper 和 Redis 分布式锁的比较</p> <p>zookeeper:****</p> <p>优点. zookeeper有封装好的框架,容易实现,有等待锁队列,抢锁效率高.</p> <p>缺点,频繁创建删除节点性能较低.</p> <p><strong>redis</strong></p> <p>优点.</p> <p>缺点,轮询setnx.处理死锁问题等等.</p> <h2 id="_3-mysql和oracle的区别"><a href="#_3-mysql和oracle的区别" class="header-anchor">#</a> 3.MySql和Oracle的区别</h2> <h3 id="一、宏观上"><a href="#一、宏观上" class="header-anchor">#</a> 一、宏观上:</h3> <p>1、Oracle是大型的数据库而Mysql是中小型数据库；Mysql是开源的，Oracle是收费的，且价格昂贵。</p> <p>2、Oracle支持大并发，大访问量，是OLTP的最好的工具。</p> <p>3、安装占用的内存也是有差别，Mysql安装完成之后占用的内存远远小于Oracle所占用的内存，并且Oracle越用所占内存也会变多。</p> <h3 id="二、微观上"><a href="#二、微观上" class="header-anchor">#</a> 二、微观上:</h3> <p>1、对于事务的支持</p> <p>Mysql对于事务默认是不支持的，只是有某些存储引擎中如：innodb可以支持；而Oracle对于事物是完全支持的。</p> <p>2、并发性</p> <p>什么是并发性？并发性是OLTP(On-Line Transaction Processing联机事务处理过程)数据库最重要的特性，并发性涉及到资源的获取、共享与锁定。</p> <p>Mysql以表锁为主，对资源锁定的力度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表的数据。</p> <p>Oracle使用行级锁，对资源锁定的力度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖于索引。所以oracle对并发性的支持要好很多。</p> <p>3、数据的持久性</p> <p>Oracle保证提交的事务均可以恢复，因为Oracle把提交的sql操作线写入了在线联机日志文件中，保存到磁盘上，如果出现数据库或者主机异常重启，重启Oracle可以靠联机在线日志恢复客户提交的数据。</p> <p>Mysql默认提交sql语句，但是如果更新过程中出现db或者主机重启的问题，也可能会丢失数据。</p> <p>4、事务隔离级别</p> <p>MySQL是repeatable read的隔离级别，而Oracle是read commited的隔离级别，同时二者都支持serializable串行化事务隔离级别，可以实现最高级别的。</p> <p>读一致性。每个session提交后其他session才能看到提交的更改。Oracle通过在undo表空间中构造多版本数据块来实现读一致性，每个session 查询时，如果对应的数据块发生变化，Oracle会在undo表空间中为这个session构造它查询时的旧的数据块。</p> <p>MySQL没有类似Oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时，要加上排它锁，其他session无法访问数据</p> <p>5、提交方式</p> <p>Oracle默认不自动提交，需要手动提交。Mysql默认自动提交。</p> <p>6、逻辑备份</p> <p>Mysql逻辑备份是要锁定数据，才能保证备份的数据是一致的，影响业务正常的DML(数据操纵语言Data Manipulation Language)使用；Oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p> <p>7、sql语句的灵活性</p> <p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能(分页)，insert可以一次插入多行数据；Oracle在这方面感觉更加稳重传统一些，Oracle的分页是通过伪列和子查询完成的，插入数据只能一行行的插入数据。</p> <p>8、数据复制</p> <p>MySQL：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p> <p>Oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p> <p>9、分区表和分区索引</p> <p>MySQL的分区表还不太成熟稳定；Oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。</p> <p>10、售后与费用</p> <p>Oracle是收费的，出问题找客服；Mysql是免费的的，开源的，出问题自己解决。</p> <p>11、权限与安全</p> <p>Oracle的权限与安全概念比较传统，中规中矩；MySQL的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。</p> <p>12、性能诊断方面</p> <p>Oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等 ；MySQL的诊断调优方法较少，主要有慢查询日志。</p> <h2 id="_4-weblogic和tomcat的区别"><a href="#_4-weblogic和tomcat的区别" class="header-anchor">#</a> 4.Weblogic和Tomcat的区别</h2> <p>1、Weblogic具有不同的功能，例如事务管理，消息队列，数据库连接处理和许多其他功能，而Tomcat具有轻量级，开源，灵活，稳定，servlet，JSP，将应用程序嵌入到tomcat异步日志记录中等等。</p> <p>2、Weblogic是具有EJB支持的完全加载的容器，而Tomcat是Servlet和JSP支持的容器。</p> <p>3、Weblogic是许可版本和基于Java EE的商业Web服务器，具有高度可扩展，快速，安全和高性能的Web服务器，而Tomcat是开源的，基于Servlet和JSP规范的参考实现。</p> <p>4、Weblogic是市场上最好的服务器，具有数据库池功能，而且购买许可证的价格有点昂贵，而Tomcat是免费的，并且在大型应用程序的功能方面存在局限性。</p> <p>5、Weblogic具有正在使用该服务器的顶级客户和客户，并且被业内的顶级客户所使用，而Tomcat也被许多客户使用，但是与Weblogic相比，它受到限制并且用户数量更少。</p> <p>6、Weblogic提供了对部署业务逻辑以及Web应用程序的支持，而Tomcat仅允许基于http或基于Web的应用程序的部署。</p> <p>7、与WebLogic相比，Weblogic的性能良好，而Tomcat的性能则较差。</p> <p>8、Weblogic具有良好的服务管理功能以及自动化的可能性，而Tomcat具有较少的IT服务管理可能性。</p> <p>9、Weblogic具有针对任何新功能或新JDK版本的更快更新，而Tomcat不会立即提供JDK版本更新或任何其他功能更新，但需要花费较长时间。</p> <p>10、Weblogic具有应用程序版本控制功能，消息传递引擎，故障排除，数据库调优，数据源池，而Apache Tomcat Server没有此功能。</p> <p>11、Weblogic具有EJB集群，JMS集群，故障转移，迁移，升级，补丁，安全更新和恢复功能，而Tomcat没有这些功能。</p> <p>结论</p> <p>Weblogic是需要许可证的企业和商业软件，具有用于大型工业应用程序的多种功能，可简化开发人员的生活，而Tomcat是轻量级的免费开源软件，适用于小型Web应用程序或公司在许可版本上投资的成本效益很高的地方。选择软件的选择取决于项目的要求和规模以及所需的功能和客户的要求，并且在设计应用程序体系结构时，可以采用相同的方法来选择任何应用程序服务器或Web服务器。</p> <h2 id="_5-gc有哪些回收器"><a href="#_5-gc有哪些回收器" class="header-anchor">#</a> 5.gc有哪些回收器.</h2> <h3 id="一、串行垃圾回收器"><a href="#一、串行垃圾回收器" class="header-anchor">#</a> 一、串行垃圾回收器</h3> <p>在JDK1.3之前，单线程回收器是唯一的选择。它的单线程意义不仅仅是说它只会使用一个CPU或一个手机线程去完成垃圾收集工作。而且它进行垃圾回收的时候，必须暂停其它所有的工作线程（Stop The  World,STW），直到它收集完成。它适合Client模式的应用，在单CPU环境下，它效率高效，由于没有线程交互的开销，专心垃圾收集自然可以获得最高的单线程效率。</p> <p>串行的垃圾收集器有两种，Serial和Serial Old，一般两者搭配使用。</p> <p>新生代采用Serial，是利用复制算法；老年代使用Serial Old采用标记-整理算法。Client应用或者命令行程序可以通过</p> <p>-XX:+UseSerialGC开启串行垃圾回收器。</p> <h3 id="二、并行垃圾回收器"><a href="#二、并行垃圾回收器" class="header-anchor">#</a> 二、并行垃圾回收器</h3> <p>并行垃圾回收器是通过多线程进行垃圾收集的。也会暂停其它所有的工作线程（Stop The World,STW）。适合Server模式以及多CPU环境。一般会和JDK1.5之后出现的CMS搭配使用。并行的垃圾回收器有以下几种：</p> <p>ParNew：Serial收集器的多线程版本，默认开启的收集线程数和CPU数量一样，运行数量可以通过修改ParallelGCThreads设定。用于新生代手机，复制算法。用-XX:+UseParNewGC,和Serial Old收集器组合进行内存回收。</p> <p>Parallel Scavenge:  关注吞吐量，吞吐量优先，吞吐量=代码运行时间/（代码运行时间+垃圾收集时间），也就是高效率利用CPU时间，尽快完成程序的运算任务可以升值最大停顿时间MaxGCPauseMillis以及，吞吐量大小GCTimeRatio。如果设置了-XX:+UseAdaptiveSizePolicy参数，则随着GC,会动态调整新生代的大小，Eden,Survivor比例等，以提供最合适的停顿时间或者最大的吞吐量。用于新生代收集，复制算法。通过-XX:+UseParallelGC参数，Server模式下默认提供了其和SerialOld进行搭配的分代收集方式。</p> <p>Parllel Old：Parallel Scavenge的老年代版本。JDK 1.6开始提供的。在此之前Parallel  Scavenge的地位也很尴尬，而有了Parllel Old之后，通过-XX:+UseParallelOldGC参数使用Parallel  Scavenge + Parallel Old器组合进行内存回收。</p> <h3 id="三、cms收集器"><a href="#三、cms收集器" class="header-anchor">#</a> 三、CMS收集器</h3> <p>CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器。从名字就能知道它是标记-清除算法的。但是它比一般的标记-清除算法要复杂一些，分为以下4个阶段：</p> <ol><li>初始标记：标记一下GC Roots能直接关联到的对象，会&quot;Stop The World&quot;。</li> <li>并发标记：GC Roots Tracing，可以和用户线程并发执行。</li> <li>重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，会“Stop The World”。</li> <li>并发清除：清除对象，可以和用户线程并发执行。</li></ol> <p>由于垃圾回收线程可以和用户线程同时运行，也就是说它是并发的，那么它会对CPU的资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/  4，当CPU&lt;4个时，并发回收是垃圾收集线程就不会少于25%，而且随着CPU减少而增加，这样会影响用户线程的执行。而且由于它是基于标记-清除算法的，那么就无法避免空间碎片的产生。CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p> <p>​    所谓浮动垃圾，在CMS并发清理阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理掉。</p> <h3 id="四、g1垃圾收集器"><a href="#四、g1垃圾收集器" class="header-anchor">#</a> 四、G1垃圾收集器</h3> <h4 id="_1、g1垃圾收集器"><a href="#_1、g1垃圾收集器" class="header-anchor">#</a> 1、G1垃圾收集器</h4> <p>把G1单独拿出来的原因是其比较复杂，在JDK 1.7确立是项目目标，在JDK 7u2版本之后发布，并在JDK 9中成为了默认的垃圾回收器。通过“-XX:+UseG1GC”启动参数即可指定使用G1 GC。</p> <p>G1从整体看还是基于标记-清除算法的，但是局部上是基于复制算法的。这样就意味者它空间整合做的比较好，因为不会产生空间碎片。G1还是并发与并行的，它能够充分利用多CPU、多核的硬件环境来缩短“stop the  world”的时间。G1还是分代收集的，但是G1不再像上文所述的垃圾收集器，需要分代配合不同的垃圾收集器，因为G1中的垃圾收集区域是“分区”（Region）的。G1的分代收集和以上垃圾收集器不同的就是除了有年轻代的ygc，全堆扫描的full GC外，还有包含所有年轻代以及部分老年代Region的Mixed GC。G1还可预测停顿，通过调整参数，制定垃圾收集的最大停顿时间。</p> <p>G1收集器的运作大致可以分为以下步骤：初始标记、并发标记、最终标记、筛选回收。其中初始标记阶段仅仅只是标记一下GC  Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark  Set）的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这个阶段需要STW，但耗时很短。并发标记阶段是从GC  Roots开始对堆中对象进行可达性分析，找到存活的对象，这阶段耗时较长，但是可以和用户线程并发运行。最终标记阶段则是为了修正在并发标记期间因用户程序继续运行而导致标记产生变化的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记需要把Remembered Set Logs的数据合并到Remembered  Sets中，这阶段需要暂停线程，但是可并行执行。最后的筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来确定回收计划。G1收集器运行示意图如下图所示。</p> <p><img src="https://img-blog.csdnimg.cn/20190222222925966.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l2YV9icm90aGVy,size_16,color_FFFFFF,t_70" alt="img"></p> <h4 id="_2、g1分区的概念"><a href="#_2、g1分区的概念" class="header-anchor">#</a> 2、G1分区的概念</h4> <p>G1的堆区在分代的基础上，引入分区的概念。G1将堆分成了若干Region,以下和”分区”代表同一概念。（这些分区不要求是连续的内存空间）Region的大小可以通过G1HeapRegionSize参数进行设置，其必须是2的幂，范围允许为1Mb到32Mb。  JVM的会基于堆内存的初始值和最大值的平均数计算分区的尺寸，平均的堆尺寸会分出约2000个Region。分区大小一旦设置，则启动之后不会再变化。如下图简单画了下G1分区模型。</p> <p><img src="https://img-blog.csdnimg.cn/20190222222954248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l2YV9icm90aGVy,size_16,color_FFFFFF,t_70" alt="img"></p> <p><strong>Eden regions(年轻代-Eden区)</strong></p> <p><strong>Survivor regions(年轻代-Survivor区)</strong></p> <p><strong>Old regions（老年代）</strong></p> <p><strong>Humongous regions（巨型对象区域）</strong></p> <p><strong>Free regions（未分配区域，也会叫做可用分区）-上图中空白的区域</strong></p> <p>G1中的****巨型对象****是指，占用了Region容量的50%以上的一个对象。Humongous区，就专门用来存储巨型对象。如果一个H区装不下一个巨型对象，则会通过连续的若干H分区来存储。因为巨型对象的转移会影响GC效率，所以并发标记阶段发现巨型对象不再存活时，会将其直接回收。ygc也会在某些情况下对巨型对象进行回收。</p> <p>分区可以有效利用内存空间，因为收集整体是使用“标记-整理”，Region之间基于“复制”算法，GC后会将存活对象复制到可用分区（未分配的分区），所以不会产生空间碎片。</p> <h4 id="_3、g1-gc的分类和过程"><a href="#_3、g1-gc的分类和过程" class="header-anchor">#</a> 3、G1 GC的分类和过程</h4> <p>JDK10 之前的G1中的GC只有Young GC,Mixed GC。Full GC处理会交给单线程的Serial Old垃圾收集器。</p> <h4 id="_4、young-gc年轻代收集"><a href="#_4、young-gc年轻代收集" class="header-anchor">#</a> 4、Young GC年轻代收集</h4> <p>在分配一般对象（非巨型对象）时，当所有Eden  region使用达到最大阀值并且无法申请足够内存时，会触发一次Young GC。每次Young GC会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。到Old区的标准就是在PLAB中得到的计算结果。因为Young GC会进行根扫描，所以会stop the world。</p> <p>Young GC的回收过程如下：</p> <p>1、根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</p> <p>2、处理Dirty card,更新RSet.</p> <p>3、扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</p> <p>4、拷贝扫描出的存活的对象到survivor2/old区</p> <p>5、处理引用队列，软引用，弱引用，虚引用</p> <h4 id="_5、mix-gc混合收集"><a href="#_5、mix-gc混合收集" class="header-anchor">#</a> <strong>5、Mix GC混合收集</strong></h4> <p>Mixed GC是G1 GC特有的，跟Full GC不同的是Mixed GC只回收部分老年代的Region。哪些old  region能够放到CSet里面，有很多参数可以控制。比如G1HeapWastePercent参数，在一次young GC之后，可以允许的堆垃圾百占比，超过这个值就会触发mixed GC。</p> <p>G1MixedGCLiveThresholdPercent参数控制的，old代分区中的存活对象比，达到阀值时，这个old分区会被放入CSet。</p> <p>Mixed GC一般会发生在一次Young GC后面,为了提高效率，Mixed GC会复用Young GC的全局的根扫描结果，因为这个Stop the world过程是必须的，整体上来说缩短了暂停时间。</p> <p>Mix GC的回收过程可以理解为Young GC后附加的全局concurrent marking，全局的并发标记主要用来处理old区（包含H区）的存活对象标记，过程如下：</p> <p>\1. 初始标记（Initial Mark）。标记GC Roots，会STW,一般会复用Young GC的暂停时间。如前文所述，初始标记会设置好所有分区的NTAMS值。</p> <p>\2.  根分区扫描（Root Region Scan）。这个阶段GC的线程可以和应用线程并发运行。其主要扫描初始标记以及之前Young GC对象转移到的Survivor分区，并标记Survivor区中引用的对象。所以此阶段的Survivor分区也叫根分区（Root Region）。</p> <p>\3. 并发标记（Concurrent Mark）。会并发标记所有非完全空闲的分区的存活对象，也即使用了SATB算法，标记各个分区。</p> <p>\4. 最终标记（Remark）。主要处理SATB缓冲区，以及并发标记阶段未标记到的漏网之鱼（存活对象），会STW,可以参考上文的SATB处理。</p> <p>\5. 清除阶段（Clean  UP）。上述SATB也提到了，会进行bitmap的swap，以及PTAMS,NTAMS互换。整理堆分区，调整相应的RSet（比如如果其中记录的Card中的对象都被回收，则这个卡片的也会从RSet中移除）,如果识别到了完全空的分区，则会清理这个分区的RSet。这个过程会STW。</p> <p>清除阶段之后，还会对存活对象进行转移（复制算法），转移到其他可用分区，所以当前的分区就变成了新的可用分区。复制转移主要是为了解决分区内的碎片问题。</p> <h4 id="_6、full-gc"><a href="#_6、full-gc" class="header-anchor">#</a> 6、Full GC</h4> <p>G1在对象复制/转移失败或者没法分配足够内存（比如巨型对象没有足够的连续分区分配）时，会触发Full GC。Full GC使用的是stop the world的单线程的Serial Old模式,所以一旦触发Full GC则会STW应用线程，并且执行效率很慢。JDK  8版本的G1是不提供Full GC的处理的。对于G1 GC的优化，很大的目标就是没有Full GC。</p> <h2 id="_6-内存新生代-老年代等"><a href="#_6-内存新生代-老年代等" class="header-anchor">#</a> 6.内存新生代.老年代等</h2> <h3 id="jvm-对象什么情况会进入到老年代"><a href="#jvm-对象什么情况会进入到老年代" class="header-anchor">#</a> JVM--对象什么情况会进入到老年代</h3> <ol><li><p>大对象:所谓的大对象是指需要大量连续内存空间的java对象,最典型的大对象就是那种很长的字符串以及数组,大对象对虚拟机的内存分配就是坏消息,尤其是一些朝生夕灭的短命大对象,写程序时应避免。</p></li> <li><p>长期存活的对象:虚拟机给每个对象定义了一个对象年龄(Age)计数器,如果对象在Eden出生并经过第一次Minor  GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1,。对象在Survivor区中每熬过一次Minor GC,年龄就增加1,当他的年龄增加到一定程度(默认是15岁),  就将会被晋升到老年代中。对象晋升到老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置。</p></li> <li><p>动态对象年龄判定:为了能更好地适应不同程度的内存状况,虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代,如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于年龄的对象就可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄。</p></li> <li><p>在一次安全Minor GC 中，仍然存活的对象不能在另一个Survivor 完全容纳，则会通过担保机制进入老年代。</p></li></ol> <h2 id="_7-为什么需要分布式锁"><a href="#_7-为什么需要分布式锁" class="header-anchor">#</a> 7.为什么需要分布式锁</h2> <h3 id="什么是分布式锁"><a href="#什么是分布式锁" class="header-anchor">#</a> 什么是分布式锁</h3> <p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</p> <h3 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="header-anchor">#</a> 为什么需要分布式锁</h3> <p>为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。</p> <p>在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p> <p>举个例子:</p> <p>机器A , 机器B是一个集群, A, B两台机器上的程序都是一样的, 具备高可用性能.</p> <p>A, B机器都有一个定时任务, 每天晚上凌晨2点需要执行一个定时任务, 但是这个定时任务只能执行一遍, 否则的话就会报错, 那A,B两台机器在执行的时候, 就需要抢锁, 谁抢到锁, 谁执行, 谁抢不到, 就不用执行了!</p> <p><a href="https://blog.csdn.net/m0_48795607/article/details/115017701" target="_blank" rel="noopener noreferrer">为什么需要分布式锁<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_8-工厂-代理模式-好好看看"><a href="#_8-工厂-代理模式-好好看看" class="header-anchor">#</a> 8.工厂,代理模式,好好看看.</h2> <h2 id="_9-hashmap是线程安全吗-为啥"><a href="#_9-hashmap是线程安全吗-为啥" class="header-anchor">#</a> 9.HashMap是线程安全吗,为啥</h2> <div class="language-JAVA extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果没有hash碰撞则直接插入元素</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>其中第六行代码是判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p> <h2 id="_10-gc线上调优经验-如果写了会被问"><a href="#_10-gc线上调优经验-如果写了会被问" class="header-anchor">#</a> 10.gc线上调优经验(如果写了会被问)</h2> <h2 id="_11-说说如果你想用zookeeper怎么用"><a href="#_11-说说如果你想用zookeeper怎么用" class="header-anchor">#</a> 11.说说如果你想用zookeeper怎么用.</h2> <p>多节点的分布式架构,分布式锁.</p> <h2 id="_12-redis和zookeeper的分布式锁有什么区别"><a href="#_12-redis和zookeeper的分布式锁有什么区别" class="header-anchor">#</a> 12.redis和zookeeper的分布式锁有什么区别</h2> <p>对于redis的分布式锁而言，它有以下缺点：</p> <ul><li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li> <li>另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮</li> <li>即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking</li></ul> <p>但是另一方面使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”</p> <p>所以使用redis作为分布式锁也不失为一种好的方案，最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。</p> <p>对于zk分布式锁而言:</p> <ul><li>zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li> <li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li></ul> <p>但是zk也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。</p> <h3 id="zookeeper实现分布式锁的原理"><a href="#zookeeper实现分布式锁的原理" class="header-anchor">#</a> zookeeper实现分布式锁的原理</h3> <p>理解了锁的原理后，就会发现，Zookeeper 天生就是一副分布式锁的胚子。</p> <p>首先，Zookeeper的每一个节点，都是一个天然的顺序发号器。</p> <p>在每一个节点下面创建子节点时，只要选择的创建类型是有序（EPHEMERAL_SEQUENTIAL 临时有序或者PERSISTENT_SEQUENTIAL 永久有序）类型，那么，新的子节点后面，会加上一个次序编号。这个次序编号，是上一个生成的次序编号加一</p> <p>比如，创建一个用于发号的节点“/test/lock”，然后以他为父亲节点，可以在这个父节点下面创建相同前缀的子节点，假定相同的前缀为“/test/lock/seq-”，在创建子节点时，同时指明是有序类型。如果是第一个创建的子节点，那么生成的子节点为/test/lock/seq-0000000000，下一个节点则为/test/lock/seq-0000000001，依次类推，等等。</p> <p>image.png</p> <p>其次，Zookeeper节点的递增性，可以规定节点编号最小的那个获得锁。</p> <p>一个zookeeper分布式锁，首先需要创建一个父节点，尽量是持久节点（PERSISTENT类型），然后每个要获得锁的线程都会在这个节点下创建个临时顺序节点，由于序号的递增性，可以规定排号最小的那个获得锁。所以，每个线程在尝试占用锁之前，首先判断自己是排号是不是当前最小，如果是，则获取锁。</p> <p>第三，Zookeeper的节点监听机制，可以保障占有锁的方式有序而且高效。</p> <p>每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的Znode。抢号成功后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个Znode 的通知就可以了。当前一个Znode 删除的时候，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后。</p> <p>Zookeeper的节点监听机制，可以说能够非常完美的，实现这种击鼓传花似的信息传递。具体的方法是，每一个等通知的Znode节点，只需要监听linsten或者 watch 监视排号在自己前面那个，而且紧挨在自己前面的那个节点。 只要上一个节点被删除了，就进行再一次判断，看看自己是不是序号最小的那个节点，如果是，则获得锁。</p> <p>为什么说Zookeeper的节点监听机制，可以说是非常完美呢？</p> <p>一条龙式的首尾相接，后面监视前面，就不怕中间截断吗？比如，在分布式环境下，由于网络的原因，或者服务器挂了或则其他的原因，如果前面的那个节点没能被程序删除成功，后面的节点不就永远等待么？</p> <p>其实，Zookeeper的内部机制，能保证后面的节点能够正常的监听到删除和获得锁。在创建取号节点的时候，尽量创建临时znode 节点而不是永久znode 节点，一旦这个 znode 的客户端与Zookeeper集群服务器失去联系，这个临时 znode 也将自动删除。排在它后面的那个节点，也能收到删除事件，从而获得锁。</p> <p>说Zookeeper的节点监听机制，是非常完美的。还有一个原因。</p> <p>Zookeeper这种首尾相接，后面监听前面的方式，可以避免羊群效应。所谓羊群效应就是每个节点挂掉，所有节点都去监听，然后做出反映，这样会给服务器带来巨大压力，所以有了临时顺序节点，当一个节点挂掉，只有它后面的那一个节点才做出反映。</p> <h2 id="_13-thread和runnable的顶级父类是什么"><a href="#_13-thread和runnable的顶级父类是什么" class="header-anchor">#</a> 13.Thread和Runnable的顶级父类是什么</h2> <p>Thread也是实现了Runnable,new Thread也是间接实现了Runnable接口.</p> <h2 id="_14-spring中用了哪些设计模式"><a href="#_14-spring中用了哪些设计模式" class="header-anchor">#</a> 14.spring中用了哪些设计模式</h2> <ul><li>代理模式—在AOP中被用的比较多。</li> <li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li> <li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li> <li>工厂模式—BeanFactory用来创建对象的实例。</li> <li>适配器--spring aop</li> <li>装饰器--spring data hashmapper</li> <li>观察者-- spring 事件驱动模型</li> <li>回调--Spring Aware回调接口</li></ul> <h2 id="_15-concurrenthashmap的链表为什么8个就转为红黑树"><a href="#_15-concurrenthashmap的链表为什么8个就转为红黑树" class="header-anchor">#</a> 15.ConcurrentHashMap的链表为什么8个就转为红黑树</h2> <p>红黑树插入为O(lgn),查询为O(lgn)，链表插入为O(1)，查询为O(n)。个数少时，插入删除成本高，用链表；个数多时，查询成本高，用红黑树。需要定一个值，比这个值大就转红黑树，比这个值小就转链表，而且要避免频繁的转换。根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p> <h2 id="_16-innodb和myisam的区别和使用"><a href="#_16-innodb和myisam的区别和使用" class="header-anchor">#</a> 16.Innodb和myisam的区别和使用</h2> <ol><li><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p></li> <li><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</p></li> <li><p>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p></li> <li><p>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p></li> <li><p>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p></li></ol> <p><strong>如何选择：</strong></p> <ol><li><p>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</p></li> <li><p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</p></li> <li><p>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</p></li> <li><p>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。</p></li></ol> <h2 id="_17-map是如何实现的"><a href="#_17-map是如何实现的" class="header-anchor">#</a> 17.map是如何实现的</h2> <p><a href="https://blog.csdn.net/xzp_12345/article/details/79251174" target="_blank" rel="noopener noreferrer">list,set,map的底层实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>HashMap实现原理要点概括</p> <p>参考文献：http://zhangshixi.iteye.com/blog/672697
参考文献：http://blog.csdn.net/lizhongkaide/article/details/50595719</p> <div class="language- extra-class"><pre><code>1. HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。
2. 底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。
3. HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。
4. HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能
5. 采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常
</code></pre></div><h2 id="_18-红黑树"><a href="#_18-红黑树" class="header-anchor">#</a> 18.红黑树</h2> <p><a href="https://baijiahao.baidu.com/s?id=1636557496125304849&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener noreferrer">有了(bst)二分查找树,avl(二分平衡树,为什么还需要红黑树)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://blog.csdn.net/csdnsevenn/article/details/97842196" target="_blank" rel="noopener noreferrer">五分钟学会红黑树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://blog.csdn.net/csdnnews/article/details/84939104" target="_blank" rel="noopener noreferrer">红黑树没有你想象的那么难<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://blog.csdn.net/qq_38685503/article/details/103425572" target="_blank" rel="noopener noreferrer">红黑树变色规则<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id=""><a href="#" class="header-anchor">#</a></h2> <h2 id="_19-mysql事务隔离级别"><a href="#_19-mysql事务隔离级别" class="header-anchor">#</a> 19.mysql事务隔离级别</h2> <p><strong>事务的 四个特征（ACID）</strong></p> <p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p> <p>1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</p> <p>2 、一致性。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说不一致的状态。</p> <p>3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p> <p>4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p> <p><strong>Mysql的四种隔离级别</strong>
SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p> <p><strong>Read Uncommitted（读取未提交内容）</strong></p> <p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p> <p><strong>Read Committed（读取提交内容）</strong></p> <p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable  Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p> <p><strong>Repeatable Read（可重读）</strong></p> <p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom  Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”  行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency  Control）机制解决了该问题。</p> <p><strong>Serializable（可串行化）</strong></p> <p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p> <p><strong>出现问题</strong></p> <p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p> <p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p> <p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p> <p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p> <p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p> <p>​		各种隔离级别和数据库异常情况对应情况如下：</p> <table><thead><tr><th>隔离级别</th> <th>脏读</th> <th>不可重复  读</th> <th>幻读</th></tr></thead> <tbody><tr><td>READ- UNCOMMITTED 读未提交</td> <td>√</td> <td>√</td> <td>√</td></tr> <tr><td>READ-COMMITTED 读已提交</td> <td>×</td> <td>√</td> <td>√</td></tr> <tr><td>REPEATABLE- READ 可重读</td> <td>×</td> <td>×</td> <td>√</td></tr> <tr><td>SERIALIZABLE 可串行化</td> <td>×</td> <td>×</td> <td>×</td></tr></tbody></table> <p><img src="https://img2018.cnblogs.com/blog/1646034/201904/1646034-20190430095830286-1397235000.png" alt="img"></p> <h2 id="_20-索引失效的情况-详见sql-md"><a href="#_20-索引失效的情况-详见sql-md" class="header-anchor">#</a> 20.索引失效的情况,详见sql.md</h2> <p>​		1、组合索引不遵循最左匹配原则</p> <p>​		2、组合索引的前面索引列使用范围查询(&lt;,&gt;,like),会导致后续的索引失效</p> <p>​		3、不要在索引上做任何操作（计算，函数，类型转换）</p> <p>​		4、is null和is not null无法使用索引</p> <p>​		5、尽量少使用or操作符，否则连接时索引会失效</p> <p>​		6、字符串不添加引号会导致索引失效</p> <p>​		7、两表关联使用的条件字段中字段的长度、编码不一致会导致索引失效</p> <p>​		8、like语句中，以%开头的模糊查询</p> <p>​		9、如果mysql中使用全表扫描比使用索引快，也会导致索引失效</p> <h2 id="_21-tcp三次握手-四次挥手"><a href="#_21-tcp三次握手-四次挥手" class="header-anchor">#</a> 21.tcp三次握手,四次挥手</h2> <ol><li>为什么要三次握手
<ol><li>为了防止服务器端开启一些无用的连接增加服务器开销
<ol><li>如果A向服务发送一次握手,B就返回ack消息,并且打开链接,但是A并没收到,那么就不会有后续了,但是打开的连接就一直在这里耗费资源.</li></ol></li> <li>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
<ol><li>如果A向服务端发送了一次握手,然后卡住了,过了一会超时了,A觉得这个事情结束了,然后服务端突然收到了,如果没有后续确认就开始认为有效,那么可能出现问题.</li></ol></li></ol></li> <li>为什么是四次挥手
<ol><li>断开连接的过程,包含主动方A和被动方B,</li> <li>A发送断开请求,B收到并且回复ack消息.表明收到了请求,但是可能还没完事.这个过程表明A已经没有事情了.</li> <li>接着B处理完了自己的事,向A发送断开消息,A回复ack消息给B.</li> <li>至此四次挥手结束,</li></ol></li></ol> <h2 id="_22-一致性哈希原理"><a href="#_22-一致性哈希原理" class="header-anchor">#</a> 22.一致性哈希原理</h2> <h2 id="_23-redis数据类型-及实现原理"><a href="#_23-redis数据类型-及实现原理" class="header-anchor">#</a> 23.Redis数据类型.及实现原理</h2> <table><thead><tr><th>结构类型</th> <th>结构存储的类型</th> <th style="text-align:left;">结构读写能力</th></tr></thead> <tbody><tr><td>STRING</td> <td>整数、字符串或者浮点数</td> <td style="text-align:left;">对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作。</td></tr> <tr><td>LIST</td> <td>一个链表，链表上的每个节点都包含了一个字符串</td> <td style="text-align:left;">从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；读取单个或者多个元素；根据值查找或者移除元素。</td></tr> <tr><td>SET</td> <td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td> <td style="text-align:left;">添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。</td></tr> <tr><td>HASH</td> <td>包含键值对的无序散列表</td> <td style="text-align:left;">添加、获取、移除单个键值对；获取所有键值对</td></tr> <tr><td>ZSET(SORT SET)</td> <td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td> <td style="text-align:left;">添加、获取、删除单个元素；根据分值范围（range）或者成员来获取元</td></tr></tbody></table> <h2 id="_24-lambda并行的线程池和java线程池的区别"><a href="#_24-lambda并行的线程池和java线程池的区别" class="header-anchor">#</a> 24.lambda并行的线程池和java线程池的区别</h2> <div class="language- extra-class"><pre class="language-text"><code>基于服务器内核的限制，如果你是八核，每次线程只能起八个，不能自定义线程池;
适用于对list密集计算操作充分利用CPU资源，如果需要调用远端服务不建议使用；
</code></pre></div><h2 id="_24-1-java线程池7个参数-四个实现方式-队列和最大线程数执行顺序"><a href="#_24-1-java线程池7个参数-四个实现方式-队列和最大线程数执行顺序" class="header-anchor">#</a> 24.1.java线程池7个参数,四个实现方式,队列和最大线程数执行顺序.</h2> <h2 id="_25-java中解决了aba问题的类"><a href="#_25-java中解决了aba问题的类" class="header-anchor">#</a> 25.java中解决了ABA问题的类</h2> <p>?</p> <h2 id="_26-cas全拼是什么-他的set的实现细节"><a href="#_26-cas全拼是什么-他的set的实现细节" class="header-anchor">#</a> 26.CAS全拼是什么.他的set的实现细节</h2> <p>compare and swap</p> <p>compare and set</p> <h2 id="_27-redis的原子setnx是在哪个版本出现的"><a href="#_27-redis的原子setnx是在哪个版本出现的" class="header-anchor">#</a> 27.redis的原子setnx是在哪个版本出现的</h2> <p>?</p> <h2 id="_28-redis的set-kv-nx-ex-是怎么保证原子的"><a href="#_28-redis的set-kv-nx-ex-是怎么保证原子的" class="header-anchor">#</a> 28.redis的set kv nx ex  是怎么保证原子的.</h2> <h2 id="_29-mysql如何排查死锁问题"><a href="#_29-mysql如何排查死锁问题" class="header-anchor">#</a> 29.mysql如何排查死锁问题.</h2> <h2 id="_30-innodb什么时候表锁-什么时候行锁"><a href="#_30-innodb什么时候表锁-什么时候行锁" class="header-anchor">#</a> 30.innodb什么时候表锁,什么时候行锁.</h2> <p>InnoDB基于索引的行锁</p> <p>InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁
在MySQL中，行级锁并不是直接锁记录，而是锁索引。</p> <h2 id="_31-java如何排查死锁"><a href="#_31-java如何排查死锁" class="header-anchor">#</a> 31.java如何排查死锁.</h2> <p>jps,jstack,jconsole</p> <h2 id="_32-向hashset中插入自定义的类有什么需要注意的"><a href="#_32-向hashset中插入自定义的类有什么需要注意的" class="header-anchor">#</a> 32.向hashset中插入自定义的类有什么需要注意的.</h2> <h2 id="_33-hashmap和hashset的底层"><a href="#_33-hashmap和hashset的底层" class="header-anchor">#</a> 33.hashMap和hashSet的底层</h2> <p><img src="https://img-blog.csdnimg.cn/20190806160824353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODQwODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h2 id="_34-hashset类是如何实现添加元素保证不重复的"><a href="#_34-hashset类是如何实现添加元素保证不重复的" class="header-anchor">#</a> 34.HashSet类是如何实现添加元素保证不重复的</h2> <p><a href="https://blog.csdn.net/u010698072/article/details/52802179" target="_blank" rel="noopener noreferrer">如何不重复<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_35-redis在你的项目中你是怎么用的-redis锁的注意事项"><a href="#_35-redis在你的项目中你是怎么用的-redis锁的注意事项" class="header-anchor">#</a> 35.redis在你的项目中你是怎么用的.redis锁的注意事项.</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/SpringCloud.html" class="prev">
        SpringCloud学习
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.18fa8910.js" defer></script><script src="/assets/js/2.d4087e47.js" defer></script><script src="/assets/js/23.fd84a8b5.js" defer></script>
  </body>
</html>
